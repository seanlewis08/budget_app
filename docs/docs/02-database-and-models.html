<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Database Models & Backend Core — Budget App Docs</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="../styles.css" />
  <link rel="stylesheet" href="docs.css" />
</head>
<body>
  <nav class="nav scrolled" id="nav">
    <div class="nav-inner">
      <a href="../" class="nav-logo">
        <svg width="28" height="28" viewBox="0 0 28 28" fill="none"><rect width="28" height="28" rx="6" fill="#5ce0b8"/><path d="M7 20V8h4.5c2.5 0 4 1.2 4 3.2 0 1.5-.9 2.5-2.2 2.9l2.8 5.9h-2.8l-2.4-5.3H9.4V20H7zm2.4-7.2h2c1.2 0 1.8-.6 1.8-1.5s-.6-1.5-1.8-1.5h-2v3z" fill="white"/><circle cx="20" cy="20" r="4" fill="#8aecd0"/></svg>
        <span>Budget App</span>
      </a>
      <div class="nav-links">
        <a href="../#features">Features</a>
        <a href="./">Docs</a>
        <a href="https://github.com/seanlewis08/budget_app" class="nav-cta" target="_blank" rel="noopener">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
          GitHub
        </a>
      </div>
    </div>
  </nav>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <h3>Walkthrough</h3>
      <nav class="docs-nav">
        <a href="01-project-setup.html">
          <span class="docs-nav-num">01</span>
          Project Setup & Foundation
        </a>
        <a href="02-database-and-models.html" class="active">
          <span class="docs-nav-num">02</span>
          Database Models & Backend Core
        </a>
        <a href="03-plaid-integration.html">
          <span class="docs-nav-num">03</span>
          Plaid Integration & Accounts
        </a>
        <a href="04-categorization-engine.html">
          <span class="docs-nav-num">04</span>
          Categorization Engine
        </a>
        <a href="05-frontend-react.html">
          <span class="docs-nav-num">05</span>
          Frontend & React UI
        </a>
        <a href="06-advanced-features.html">
          <span class="docs-nav-num">06</span>
          Advanced Features
        </a>
        <a href="07-electron-and-deployment.html">
          <span class="docs-nav-num">07</span>
          Electron & Deployment
        </a>
      </nav>
    </aside>

    <main class="docs-content">
      <div class="md-content">
<h1 id="part-2-database-models-backend-core">Part 2 — Database Models &amp; Backend Core</h1>
<p>This part builds the SQLite database layer, defines all ORM models, creates the migration system, and wires up the FastAPI application skeleton with lifespan management.</p>
<hr>
<h2 id="21-database-setup-backenddatabasepy">2.1 Database Setup (<code>backend/database.py</code>)</h2>
<p>The database lives at <code>~/BudgetApp/budget.db</code> — outside the project directory so it survives code updates and reinstalls. We use SQLAlchemy 2.0 with SQLite.</p>
<pre><code class="language-python">&quot;&quot;&quot;
Database setup and session management for SQLite.
The database file lives at ~/BudgetApp/budget.db by default,
persisting across app updates.
&quot;&quot;&quot;

import os
from pathlib import Path
from sqlalchemy import create_engine, event
from sqlalchemy.orm import sessionmaker, declarative_base

# Database location: ~/BudgetApp/budget.db
DB_DIR = Path.home() / &quot;BudgetApp&quot;
DB_DIR.mkdir(exist_ok=True)
DB_PATH = DB_DIR / &quot;budget.db&quot;

DATABASE_URL = f&quot;sqlite:///{DB_PATH}&quot;

engine = create_engine(
    DATABASE_URL,
    connect_args={
        &quot;check_same_thread&quot;: False,  # Required for SQLite + FastAPI
        &quot;timeout&quot;: 30,  # Wait up to 30s for locks (default is 5s)
    },
    echo=False,
)


# Enable WAL mode and foreign keys for SQLite
@event.listens_for(engine, &quot;connect&quot;)
def set_sqlite_pragma(dbapi_connection, connection_record):
    cursor = dbapi_connection.cursor()
    cursor.execute(&quot;PRAGMA journal_mode=WAL&quot;)
    cursor.execute(&quot;PRAGMA foreign_keys=ON&quot;)
    cursor.close()


SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()


def get_db():
    &quot;&quot;&quot;FastAPI dependency that provides a database session.&quot;&quot;&quot;
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


def init_db():
    &quot;&quot;&quot;Create all tables if they don't exist.&quot;&quot;&quot;
    from . import models  # noqa: F401 — import to register models
    Base.metadata.create_all(bind=engine)
</code></pre>
<p>Key design decisions:</p>
<ul>
<li><strong>WAL mode</strong> (<code>PRAGMA journal_mode=WAL</code>): Allows concurrent reads during writes. Essential when the background sync scheduler writes transactions while the frontend reads them.</li>
<li><strong>Foreign keys</strong> (<code>PRAGMA foreign_keys=ON</code>): SQLite has foreign keys disabled by default. This pragma enforces referential integrity.</li>
<li><strong><code>check_same_thread=False</code></strong>: SQLite normally restricts connections to the thread that created them. FastAPI uses multiple threads, so this flag is required.</li>
<li><strong>30-second timeout</strong>: Prevents <code>database is locked</code> errors when multiple processes (app + sync daemon) access the same file.</li>
<li><strong><code>get_db()</code> as a generator</strong>: This pattern lets FastAPI's dependency injection system automatically close the session after each request.</li>
</ul>
<hr>
<h2 id="22-orm-models-backendmodelspy">2.2 ORM Models (<code>backend/models.py</code>)</h2>
<p>The app has eight models organized into three logical groups: taxonomy, financial data, and system tables.</p>
<h3 id="category">Category</h3>
<p>Two-level taxonomy: parent categories (e.g., "Food") contain child subcategories (e.g., "Groceries", "Fast Food", "Restaurant"). The self-referential <code>parent_id</code> foreign key creates the hierarchy.</p>
<pre><code class="language-python">class Category(Base):
    __tablename__ = &quot;categories&quot;

    id = Column(Integer, primary_key=True, autoincrement=True)
    short_desc = Column(String(100), unique=True, nullable=False, index=True)
    display_name = Column(String(100), nullable=False)
    parent_id = Column(Integer, ForeignKey(&quot;categories.id&quot;), nullable=True)
    color = Column(String(7), nullable=True)  # hex color for charts
    is_income = Column(Boolean, default=False)
    is_recurring = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    parent = relationship(&quot;Category&quot;, remote_side=[id], backref=&quot;children&quot;)
    transactions = relationship(&quot;Transaction&quot;, back_populates=&quot;category&quot;,
                                foreign_keys=&quot;Transaction.category_id&quot;)
    budgets = relationship(&quot;Budget&quot;, back_populates=&quot;category&quot;)
    merchant_mappings = relationship(&quot;MerchantMapping&quot;, back_populates=&quot;category&quot;)
</code></pre>
<ul>
<li><code>short_desc</code> is the internal key (e.g., <code>"groceries"</code>, <code>"fast_food"</code>) — unique, used for lookups</li>
<li><code>display_name</code> is the user-facing label (e.g., <code>"Groceries"</code>, <code>"Fast Food"</code>)</li>
<li><code>color</code> stores a hex color code for chart rendering</li>
<li><code>is_income</code> flags income categories so spending reports can exclude them</li>
<li><code>is_recurring</code> marks categories like rent, subscriptions, and utilities for the recurring monitor</li>
</ul>
<h3 id="account">Account</h3>
<p>Represents a bank account. Each account can be connected to Plaid for automatic transaction syncing, or used as a target for CSV imports.</p>
<pre><code class="language-python">class Account(Base):
    __tablename__ = &quot;accounts&quot;

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(100), nullable=False)
    institution = Column(String(50), nullable=False)      # &quot;discover&quot;, &quot;sofi&quot;, &quot;wellsfargo&quot;
    account_type = Column(String(20), nullable=False)      # &quot;checking&quot;, &quot;savings&quot;, &quot;credit&quot;
    plaid_item_id = Column(String(100), nullable=True)
    plaid_access_token = Column(Text, nullable=True)       # encrypted with Fernet
    plaid_cursor = Column(Text, nullable=True)
    plaid_account_id = Column(String(100), nullable=True)
    plaid_connection_status = Column(String(20), default=&quot;disconnected&quot;, nullable=False)
    last_synced_at = Column(DateTime, nullable=True)
    last_sync_error = Column(Text, nullable=True)
    balance_current = Column(Float, nullable=True)
    balance_available = Column(Float, nullable=True)
    balance_limit = Column(Float, nullable=True)           # credit limit
    balance_updated_at = Column(DateTime, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    transactions = relationship(&quot;Transaction&quot;, back_populates=&quot;account&quot;)
</code></pre>
<ul>
<li><code>plaid_access_token</code> is encrypted at rest using Fernet symmetric encryption (covered in Part 3)</li>
<li><code>plaid_cursor</code> stores the Plaid transaction sync cursor for incremental updates</li>
<li><code>plaid_connection_status</code> tracks the state: <code>"disconnected"</code>, <code>"connected"</code>, or <code>"error"</code></li>
</ul>
<h3 id="transaction">Transaction</h3>
<p>The core financial record. Every transaction belongs to an account and optionally has a confirmed category and/or a predicted category.</p>
<pre><code class="language-python">class Transaction(Base):
    __tablename__ = &quot;transactions&quot;

    id = Column(Integer, primary_key=True, autoincrement=True)
    account_id = Column(Integer, ForeignKey(&quot;accounts.id&quot;), nullable=False)
    plaid_transaction_id = Column(String(100), nullable=True, unique=True)
    date = Column(Date, nullable=False)
    description = Column(Text, nullable=False)          # Raw from bank
    merchant_name = Column(String(200), nullable=True)  # Cleaned
    amount = Column(Float, nullable=False)              # Positive = expense, negative = income
    category_id = Column(Integer, ForeignKey(&quot;categories.id&quot;), nullable=True)
    predicted_category_id = Column(Integer, ForeignKey(&quot;categories.id&quot;), nullable=True)
    status = Column(String(20), default=&quot;pending_review&quot;, nullable=False)
    source = Column(String(20), default=&quot;csv_import&quot;, nullable=False)
    is_pending = Column(Boolean, default=False)
    categorization_tier = Column(String(20), nullable=True)
    prediction_confidence = Column(Float, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    __table_args__ = (
        Index(&quot;idx_transactions_date&quot;, &quot;date&quot;),
        Index(&quot;idx_transactions_status&quot;, &quot;status&quot;),
        Index(&quot;idx_transactions_account_date&quot;, &quot;account_id&quot;, &quot;date&quot;),
    )

    account = relationship(&quot;Account&quot;, back_populates=&quot;transactions&quot;)
    category = relationship(&quot;Category&quot;, foreign_keys=[category_id])
    predicted_category = relationship(&quot;Category&quot;, foreign_keys=[predicted_category_id])
    notifications = relationship(&quot;NotificationLog&quot;, back_populates=&quot;transaction&quot;)
</code></pre>
<p>Important columns:</p>
<ul>
<li><strong><code>amount</code></strong>: Sign convention is positive = expense, negative = income (Plaid's convention)</li>
<li><strong><code>category_id</code></strong> vs <strong><code>predicted_category_id</code></strong>: The categorization engine writes to <code>predicted_category_id</code>. When the user confirms (or it's auto-confirmed), the value is copied to <code>category_id</code>.</li>
<li><strong><code>status</code></strong>: Lifecycle is <code>"pending_review"</code> → <code>"pending_save"</code> (staged) → <code>"confirmed"</code> or <code>"auto_confirmed"</code></li>
<li><strong><code>source</code></strong>: Either <code>"csv_import"</code>, <code>"plaid"</code>, or <code>"archive"</code></li>
<li><strong><code>categorization_tier</code></strong>: Records which tier matched: <code>"amount_rule"</code>, <code>"merchant_map"</code>, or <code>"ai"</code></li>
<li><strong><code>prediction_confidence</code></strong>: 0.0–1.0 score. Amount rules get 1.0, merchant maps get their confidence level, AI gets 0.7.</li>
</ul>
<h3 id="supporting-models">Supporting Models</h3>
<pre><code class="language-python">class DeletedTransaction(Base):
    &quot;&quot;&quot;Audit log of deleted transactions — enables undo.&quot;&quot;&quot;
    __tablename__ = &quot;deleted_transactions&quot;

    id = Column(Integer, primary_key=True, autoincrement=True)
    original_id = Column(Integer, nullable=False)
    account_id = Column(Integer, nullable=True)
    account_name = Column(String(200), nullable=True)
    date = Column(Date, nullable=False)
    description = Column(Text, nullable=False)
    merchant_name = Column(String(200), nullable=True)
    amount = Column(Float, nullable=False)
    category_name = Column(String(100), nullable=True)
    status = Column(String(20), nullable=True)
    source = Column(String(20), nullable=True)
    deleted_at = Column(DateTime, default=datetime.utcnow)


class MerchantMapping(Base):
    &quot;&quot;&quot;Tier 2 categorization: learned merchant → category patterns.&quot;&quot;&quot;
    __tablename__ = &quot;merchant_mappings&quot;

    id = Column(Integer, primary_key=True, autoincrement=True)
    merchant_pattern = Column(String(200), nullable=False, index=True)
    category_id = Column(Integer, ForeignKey(&quot;categories.id&quot;), nullable=False)
    confidence = Column(Integer, default=1)
    created_at = Column(DateTime, default=datetime.utcnow)

    __table_args__ = (
        UniqueConstraint(&quot;merchant_pattern&quot;, name=&quot;uq_merchant_pattern&quot;),
    )

    category = relationship(&quot;Category&quot;, back_populates=&quot;merchant_mappings&quot;)


class AmountRule(Base):
    &quot;&quot;&quot;Tier 1 categorization: amount-based disambiguation for ambiguous merchants.&quot;&quot;&quot;
    __tablename__ = &quot;amount_rules&quot;

    id = Column(Integer, primary_key=True, autoincrement=True)
    description_pattern = Column(String(100), nullable=False)  # e.g., &quot;apple&quot;, &quot;venmo&quot;
    amount = Column(Float, nullable=False)
    tolerance = Column(Float, default=0.01)
    short_desc = Column(String(100), nullable=False)
    category_id = Column(Integer, ForeignKey(&quot;categories.id&quot;), nullable=False)
    notes = Column(Text, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)

    __table_args__ = (
        Index(&quot;idx_amount_rules_pattern&quot;, &quot;description_pattern&quot;),
    )

    category = relationship(&quot;Category&quot;)


class Budget(Base):
    &quot;&quot;&quot;Monthly budget targets per category.&quot;&quot;&quot;
    __tablename__ = &quot;budgets&quot;

    id = Column(Integer, primary_key=True, autoincrement=True)
    category_id = Column(Integer, ForeignKey(&quot;categories.id&quot;), nullable=False)
    month = Column(String(7), nullable=False)  # &quot;2025-01&quot;
    amount = Column(Float, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

    __table_args__ = (
        UniqueConstraint(&quot;category_id&quot;, &quot;month&quot;, name=&quot;uq_budget_category_month&quot;),
    )

    category = relationship(&quot;Category&quot;, back_populates=&quot;budgets&quot;)


class NotificationLog(Base):
    &quot;&quot;&quot;Email notification tracking.&quot;&quot;&quot;
    __tablename__ = &quot;notification_log&quot;

    id = Column(Integer, primary_key=True, autoincrement=True)
    transaction_id = Column(Integer, ForeignKey(&quot;transactions.id&quot;), nullable=False)
    email_message_id = Column(String(200), nullable=True)
    sent_at = Column(DateTime, default=datetime.utcnow)
    replied_at = Column(DateTime, nullable=True)
    reply_category = Column(String(100), nullable=True)

    transaction = relationship(&quot;Transaction&quot;, back_populates=&quot;notifications&quot;)


class SyncLog(Base):
    &quot;&quot;&quot;Log of every sync attempt for audit trail.&quot;&quot;&quot;
    __tablename__ = &quot;sync_log&quot;

    id = Column(Integer, primary_key=True, autoincrement=True)
    account_id = Column(Integer, ForeignKey(&quot;accounts.id&quot;), nullable=False)
    trigger = Column(String(20), nullable=False)    # &quot;scheduled&quot;, &quot;manual&quot;, &quot;retry&quot;
    status = Column(String(20), nullable=False)     # &quot;success&quot;, &quot;error&quot;, &quot;partial&quot;
    added = Column(Integer, default=0)
    modified = Column(Integer, default=0)
    removed = Column(Integer, default=0)
    error_message = Column(Text, nullable=True)
    duration_seconds = Column(Float, nullable=True)
    started_at = Column(DateTime, default=datetime.utcnow)

    __table_args__ = (
        Index(&quot;idx_synclog_account_started&quot;, &quot;account_id&quot;, &quot;started_at&quot;),
    )

    account = relationship(&quot;Account&quot;)
</code></pre>
<hr>
<h2 id="23-schema-migrations-backendmigrationspy">2.3 Schema Migrations (<code>backend/migrations.py</code>)</h2>
<p>Since we use SQLite (no Alembic), we handle schema changes with a lightweight migration function that inspects existing columns and adds missing ones:</p>
<pre><code class="language-python">&quot;&quot;&quot;
Lightweight SQLite schema migrations.
Runs on every startup — checks for missing columns and adds them.
&quot;&quot;&quot;

import logging
from sqlalchemy import inspect, text
from .database import engine, SessionLocal

logger = logging.getLogger(__name__)


def run_migrations():
    &quot;&quot;&quot;Add any missing columns to existing tables.&quot;&quot;&quot;
    inspector = inspect(engine)

    # Accounts table migrations
    account_columns = {col[&quot;name&quot;] for col in inspector.get_columns(&quot;accounts&quot;)}
    migrations = {
        &quot;plaid_account_id&quot;: &quot;VARCHAR(100)&quot;,
        &quot;plaid_connection_status&quot;: &quot;VARCHAR(20) DEFAULT 'disconnected'&quot;,
        &quot;last_synced_at&quot;: &quot;DATETIME&quot;,
        &quot;last_sync_error&quot;: &quot;TEXT&quot;,
        &quot;balance_current&quot;: &quot;REAL&quot;,
        &quot;balance_available&quot;: &quot;REAL&quot;,
        &quot;balance_limit&quot;: &quot;REAL&quot;,
        &quot;balance_updated_at&quot;: &quot;DATETIME&quot;,
    }

    with engine.connect() as conn:
        for col_name, col_type in migrations.items():
            if col_name not in account_columns:
                conn.execute(text(
                    f&quot;ALTER TABLE accounts ADD COLUMN {col_name} {col_type}&quot;
                ))
                logger.info(f&quot;Added column accounts.{col_name}&quot;)
        conn.commit()

    # Transactions table migrations
    txn_columns = {col[&quot;name&quot;] for col in inspector.get_columns(&quot;transactions&quot;)}
    if &quot;prediction_confidence&quot; not in txn_columns:
        with engine.connect() as conn:
            conn.execute(text(
                &quot;ALTER TABLE transactions ADD COLUMN prediction_confidence REAL&quot;
            ))
            conn.commit()
            logger.info(&quot;Added column transactions.prediction_confidence&quot;)

        # Backfill confidence values based on categorization tier
        db = SessionLocal()
        try:
            db.execute(text(
                &quot;UPDATE transactions SET prediction_confidence = 0.7 &quot;
                &quot;WHERE categorization_tier = 'ai' AND prediction_confidence IS NULL&quot;
            ))
            db.execute(text(
                &quot;UPDATE transactions SET prediction_confidence = 1.0 &quot;
                &quot;WHERE categorization_tier = 'amount_rule' AND prediction_confidence IS NULL&quot;
            ))
            db.execute(text(
                &quot;UPDATE transactions SET prediction_confidence = 0.8 &quot;
                &quot;WHERE categorization_tier = 'merchant_map' AND prediction_confidence IS NULL&quot;
            ))
            db.execute(text(
                &quot;UPDATE transactions SET prediction_confidence = 1.0 &quot;
                &quot;WHERE prediction_confidence &gt; 1.0&quot;
            ))
            db.commit()
            logger.info(&quot;Backfilled prediction_confidence values&quot;)
        finally:
            db.close()
</code></pre>
<p>This approach:</p>
<ul>
<li>Runs automatically on every startup (idempotent — checks before adding)</li>
<li>No migration files to track or apply manually</li>
<li>Works well for a single-developer app where you control the schema</li>
</ul>
<hr>
<h2 id="24-fastapi-application-backendmainpy">2.4 FastAPI Application (<code>backend/main.py</code>)</h2>
<p>The full application wires together the database, migrations, seed data, background scheduler, and all API routers:</p>
<pre><code class="language-python">&quot;&quot;&quot;
Budget App — FastAPI Backend
Main entry point. Registers all routers and initializes the database.
&quot;&quot;&quot;

import os
from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from dotenv import load_dotenv

load_dotenv()

from .database import init_db
from .investments_database import init_investments_db
from .migrations import run_migrations
from .routers import transactions, categories, budgets, import_csv, notifications, accounts, archive, investments, insights
from .services.seed_data import seed_categories_and_accounts
from .services.sync_scheduler import start_scheduler, stop_scheduler


@asynccontextmanager
async def lifespan(app: FastAPI):
    &quot;&quot;&quot;Run on startup: create tables, migrate, seed data, start sync scheduler.&quot;&quot;&quot;
    init_db()
    init_investments_db()
    run_migrations()
    seed_categories_and_accounts()
    start_scheduler()
    yield
    stop_scheduler()


app = FastAPI(
    title=&quot;Budget App&quot;,
    description=&quot;Personal finance tracker with AI-powered categorization&quot;,
    version=&quot;0.1.0&quot;,
    lifespan=lifespan,
)

# CORS — allow the Electron renderer (React) to call the API
app.add_middleware(
    CORSMiddleware,
    allow_origins=[&quot;http://localhost:3000&quot;, &quot;http://localhost:5173&quot;],
    allow_credentials=True,
    allow_methods=[&quot;*&quot;],
    allow_headers=[&quot;*&quot;],
)

# Register routers
app.include_router(transactions.router, prefix=&quot;/api/transactions&quot;, tags=[&quot;Transactions&quot;])
app.include_router(categories.router, prefix=&quot;/api/categories&quot;, tags=[&quot;Categories&quot;])
app.include_router(budgets.router, prefix=&quot;/api/budgets&quot;, tags=[&quot;Budgets&quot;])
app.include_router(import_csv.router, prefix=&quot;/api/import&quot;, tags=[&quot;CSV Import&quot;])
app.include_router(notifications.router, prefix=&quot;/api/notifications&quot;, tags=[&quot;Notifications&quot;])
app.include_router(accounts.router, prefix=&quot;/api/accounts&quot;, tags=[&quot;Accounts&quot;])
app.include_router(archive.router, prefix=&quot;/api/archive&quot;, tags=[&quot;Archive Import&quot;])
app.include_router(investments.router, prefix=&quot;/api/investments&quot;, tags=[&quot;Investments&quot;])
app.include_router(insights.router, prefix=&quot;/api/insights&quot;, tags=[&quot;Financial Insights&quot;])


@app.get(&quot;/health&quot;)
def health_check():
    &quot;&quot;&quot;Health check endpoint used by Electron to verify backend is ready.&quot;&quot;&quot;
    return {&quot;status&quot;: &quot;ok&quot;, &quot;version&quot;: &quot;0.1.0&quot;}


@app.get(&quot;/api/stats&quot;)
def get_stats():
    &quot;&quot;&quot;Quick stats for the sidebar badge.&quot;&quot;&quot;
    from .database import SessionLocal
    from .models import Transaction

    db = SessionLocal()
    try:
        total = db.query(Transaction).count()
        pending = db.query(Transaction).filter(
            Transaction.status == &quot;pending_review&quot;
        ).count()
        pending_save = db.query(Transaction).filter(
            Transaction.status == &quot;pending_save&quot;
        ).count()
        confirmed = db.query(Transaction).filter(
            Transaction.status.in_([&quot;confirmed&quot;, &quot;auto_confirmed&quot;])
        ).count()
        return {
            &quot;total_transactions&quot;: total,
            &quot;pending_review&quot;: pending,
            &quot;pending_save&quot;: pending_save,
            &quot;confirmed&quot;: confirmed,
        }
    finally:
        db.close()
</code></pre>
<p>The startup sequence is:</p>
<ol>
<li><code>init_db()</code> — creates all main database tables if they don't exist</li>
<li><code>init_investments_db()</code> — creates investment database tables</li>
<li><code>run_migrations()</code> — adds any missing columns to existing tables</li>
<li><code>seed_categories_and_accounts()</code> — inserts default categories, accounts, merchant mappings, and amount rules (idempotent)</li>
<li><code>start_scheduler()</code> — starts APScheduler background jobs for automatic syncing and price fetching</li>
</ol>
<p>On shutdown, <code>stop_scheduler()</code> gracefully stops background jobs.</p>
<hr>
<h2 id="whats-next">What's Next</h2>
<p>With the database layer and FastAPI skeleton in place, Part 3 covers Plaid integration: connecting bank accounts, encrypting access tokens, and syncing transactions automatically.</p>
<p>→ <a href="03-plaid-integration.md">Part 3: Plaid Integration &amp; Account Management</a></p>
      </div>
      <div class="docs-nav-footer">
        <a href="01-project-setup.html" class="docs-nav-link prev">
  <span class="label">&larr; Previous</span>
  <span class="title">Project Setup & Foundation</span>
</a>
        <a href="03-plaid-integration.html" class="docs-nav-link next">
  <span class="label">Next &rarr;</span>
  <span class="title">Plaid Integration & Accounts</span>
</a>
      </div>
    </main>
  </div>
</body>
</html>
