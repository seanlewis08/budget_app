<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Plaid Integration & Accounts — Budget App Docs</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="../styles.css" />
  <link rel="stylesheet" href="docs.css" />
</head>
<body>
  <nav class="nav scrolled" id="nav">
    <div class="nav-inner">
      <a href="../" class="nav-logo">
        <svg width="28" height="28" viewBox="0 0 28 28" fill="none"><rect width="28" height="28" rx="6" fill="#5ce0b8"/><path d="M7 20V8h4.5c2.5 0 4 1.2 4 3.2 0 1.5-.9 2.5-2.2 2.9l2.8 5.9h-2.8l-2.4-5.3H9.4V20H7zm2.4-7.2h2c1.2 0 1.8-.6 1.8-1.5s-.6-1.5-1.8-1.5h-2v3z" fill="white"/><circle cx="20" cy="20" r="4" fill="#8aecd0"/></svg>
        <span>Budget App</span>
      </a>
      <div class="nav-links">
        <a href="../#features">Features</a>
        <a href="./">Docs</a>
        <a href="https://github.com/seanlewis08/budget-app" class="nav-cta" target="_blank" rel="noopener">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
          GitHub
        </a>
      </div>
    </div>
  </nav>

  <div class="docs-layout">
    <aside class="docs-sidebar">
      <h3>Walkthrough</h3>
      <nav class="docs-nav">
        <a href="01-project-setup.html">
          <span class="docs-nav-num">01</span>
          Project Setup & Foundation
        </a>
        <a href="02-database-and-models.html">
          <span class="docs-nav-num">02</span>
          Database Models & Backend Core
        </a>
        <a href="03-plaid-integration.html" class="active">
          <span class="docs-nav-num">03</span>
          Plaid Integration & Accounts
        </a>
        <a href="04-categorization-engine.html">
          <span class="docs-nav-num">04</span>
          Categorization Engine
        </a>
        <a href="05-frontend-react.html">
          <span class="docs-nav-num">05</span>
          Frontend & React UI
        </a>
        <a href="06-advanced-features.html">
          <span class="docs-nav-num">06</span>
          Advanced Features
        </a>
        <a href="07-electron-and-deployment.html">
          <span class="docs-nav-num">07</span>
          Electron & Deployment
        </a>
      </nav>
    </aside>

    <main class="docs-content">
      <div class="md-content">
<h1 id="part-3-plaid-integration-account-management">Part 3 — Plaid Integration &amp; Account Management</h1>
<p>This part covers connecting bank accounts through the Plaid API, encrypting access tokens at rest, syncing transactions incrementally, and the API endpoints that manage accounts.</p>
<hr>
<h2 id="31-how-plaid-works">3.1 How Plaid Works</h2>
<p>Plaid is a middleware between your app and the user's bank. The flow is:</p>
<pre><code>1. Backend creates a &quot;link token&quot; (short-lived, per-session)
2. Frontend opens the Plaid Link widget using that token
3. User logs into their bank inside the Plaid widget
4. Plaid returns a &quot;public token&quot; to the frontend
5. Frontend sends the public token to the backend
6. Backend exchanges it for a permanent &quot;access token&quot;
7. Backend uses the access token to pull transactions
</code></pre>
<p>You'll need a Plaid account. The sandbox environment is free and provides test data. For real bank connections, you need a development or production plan.</p>
<hr>
<h2 id="32-plaid-service-backendservicesplaid_servicepy">3.2 Plaid Service (<code>backend/services/plaid_service.py</code>)</h2>
<p>This is the largest service file (~950 lines). Here are the key components.</p>
<h3 id="client-initialization">Client Initialization</h3>
<p>The Plaid client is lazily initialized on first use, configured by environment variables:</p>
<pre><code class="language-python">import os
from plaid.api import plaid_api
from plaid.model.products import Products
from plaid.model.country_code import CountryCode
from plaid import Configuration, ApiClient

class PlaidService:
    _client = None

    @property
    def client(self):
        if self._client is None:
            env = os.getenv(&quot;PLAID_ENV&quot;, &quot;sandbox&quot;)
            host = {
                &quot;sandbox&quot;: &quot;https://sandbox.plaid.com&quot;,
                &quot;development&quot;: &quot;https://development.plaid.com&quot;,
                &quot;production&quot;: &quot;https://production.plaid.com&quot;,
            }[env]

            # Use production secret if available and in production mode
            secret = os.getenv(&quot;PLAID_PRODUCTION_SECRET&quot;) if env == &quot;production&quot; \
                     else os.getenv(&quot;PLAID_SECRET&quot;)

            config = Configuration(
                host=host,
                api_key={
                    &quot;clientId&quot;: os.getenv(&quot;PLAID_CLIENT_ID&quot;),
                    &quot;secret&quot;: secret,
                }
            )
            api_client = ApiClient(config)
            self._client = plaid_api.PlaidApi(api_client)
        return self._client
</code></pre>
<h3 id="token-encryption">Token Encryption</h3>
<p>Plaid access tokens grant full access to a user's bank data, so they're encrypted at rest using Fernet (symmetric encryption from the <code>cryptography</code> library):</p>
<pre><code class="language-python">from cryptography.fernet import Fernet
from pathlib import Path

KEY_PATH = Path.home() / &quot;BudgetApp&quot; / &quot;.encryption_key&quot;

def _get_or_create_key(self):
    &quot;&quot;&quot;Load or generate the Fernet encryption key.&quot;&quot;&quot;
    if KEY_PATH.exists():
        return KEY_PATH.read_bytes()
    else:
        key = Fernet.generate_key()
        KEY_PATH.write_bytes(key)
        KEY_PATH.chmod(0o600)  # Owner-only read/write
        return key

def encrypt_token(self, token: str) -&gt; str:
    key = self._get_or_create_key()
    f = Fernet(key)
    return f.encrypt(token.encode()).decode()

def decrypt_token(self, encrypted: str) -&gt; str:
    key = self._get_or_create_key()
    f = Fernet(key)
    return f.decrypt(encrypted.encode()).decode()
</code></pre>
<p>The encryption key is stored at <code>~/BudgetApp/.encryption_key</code> with <code>0o600</code> permissions (owner-only). It's auto-generated on first use if missing.</p>
<h3 id="link-token-creation">Link Token Creation</h3>
<p>Creates a temporary link token that the frontend needs to open the Plaid Link widget:</p>
<pre><code class="language-python">from plaid.model.link_token_create_request import LinkTokenCreateRequest
from plaid.model.link_token_create_request_user import LinkTokenCreateRequestUser

def create_link_token(self):
    request = LinkTokenCreateRequest(
        user=LinkTokenCreateRequestUser(client_user_id=&quot;budget-app-user&quot;),
        client_name=&quot;Budget App&quot;,
        products=[Products(&quot;transactions&quot;)],
        country_codes=[CountryCode(&quot;US&quot;)],
        language=&quot;en&quot;,
        redirect_uri=&quot;http://localhost:5173/oauth-callback&quot;,
    )
    response = self.client.link_token_create(request)
    return response.link_token
</code></pre>
<p>The <code>redirect_uri</code> is needed for OAuth-based banks (banks that redirect to their own login page instead of using Plaid's in-widget login).</p>
<h3 id="token-exchange-and-account-linking">Token Exchange and Account Linking</h3>
<p>After the user completes the Plaid Link flow, the frontend sends the public token. The backend exchanges it for a permanent access token and links accounts:</p>
<pre><code class="language-python">from plaid.model.item_public_token_exchange_request import ItemPublicTokenExchangeRequest

def exchange_public_token(self, account_id: int, public_token: str, db):
    &quot;&quot;&quot;Exchange Plaid public token for access token and link the account.&quot;&quot;&quot;
    # Exchange for permanent access token
    request = ItemPublicTokenExchangeRequest(public_token=public_token)
    response = self.client.item_public_token_exchange(request)
    access_token = response.access_token
    item_id = response.item_id

    # Encrypt and store
    account = db.query(Account).get(account_id)
    account.plaid_access_token = self.encrypt_token(access_token)
    account.plaid_item_id = item_id
    account.plaid_connection_status = &quot;connected&quot;

    # Match Plaid's sub-accounts to local accounts
    self._match_plaid_accounts(access_token, item_id, db)

    db.commit()
    return {&quot;status&quot;: &quot;linked&quot;, &quot;item_id&quot;: item_id}
</code></pre>
<h3 id="account-matching">Account Matching</h3>
<p>A single Plaid "item" (one bank login) can contain multiple accounts (checking, savings, credit). The service matches them to local accounts by type:</p>
<pre><code class="language-python">def _match_plaid_accounts(self, access_token, item_id, db):
    &quot;&quot;&quot;Match Plaid's accounts to local Account records.&quot;&quot;&quot;
    from plaid.model.accounts_get_request import AccountsGetRequest

    response = self.client.accounts_get(
        AccountsGetRequest(access_token=access_token)
    )

    for plaid_acct in response.accounts:
        # Try to match by account type (checking, savings, credit)
        local = (
            db.query(Account)
            .filter(
                Account.plaid_item_id == item_id,
                Account.plaid_account_id.is_(None),
            )
            .first()
        )
        if local:
            local.plaid_account_id = plaid_acct.account_id
            local.plaid_connection_status = &quot;connected&quot;
</code></pre>
<h3 id="transaction-sync">Transaction Sync</h3>
<p>The core sync method uses Plaid's cursor-based pagination to fetch only new/modified/removed transactions since the last sync:</p>
<pre><code class="language-python">from plaid.model.transactions_sync_request import TransactionsSyncRequest

def sync_transactions(self, account, db, trigger=&quot;manual&quot;):
    &quot;&quot;&quot;Incremental transaction sync using Plaid's cursor-based API.&quot;&quot;&quot;
    start_time = datetime.utcnow()
    access_token = self.decrypt_token(account.plaid_access_token)
    cursor = account.plaid_cursor or &quot;&quot;

    added_count = 0
    modified_count = 0
    removed_count = 0

    try:
        has_more = True
        while has_more:
            request = TransactionsSyncRequest(
                access_token=access_token,
                cursor=cursor,
            )
            response = self.client.transactions_sync(request)

            # Process added transactions
            for txn in response.added:
                if txn.pending:
                    continue  # Skip pending transactions

                # Deduplicate by plaid_transaction_id
                existing = db.query(Transaction).filter(
                    Transaction.plaid_transaction_id == txn.transaction_id
                ).first()
                if existing:
                    continue

                new_txn = Transaction(
                    account_id=account.id,
                    plaid_transaction_id=txn.transaction_id,
                    date=txn.date,
                    description=txn.name,
                    merchant_name=txn.merchant_name or txn.name,
                    amount=txn.amount,  # Plaid: positive = expense
                    source=&quot;plaid&quot;,
                    status=&quot;pending_review&quot;,
                )
                db.add(new_txn)
                db.flush()

                # Auto-categorize
                categorize_transaction(new_txn, db)
                added_count += 1

            # Process modified transactions
            for txn in response.modified:
                existing = db.query(Transaction).filter(
                    Transaction.plaid_transaction_id == txn.transaction_id
                ).first()
                if existing:
                    existing.amount = txn.amount
                    existing.description = txn.name
                    existing.merchant_name = txn.merchant_name or txn.name
                    modified_count += 1

            # Process removed transactions
            for txn in response.removed:
                existing = db.query(Transaction).filter(
                    Transaction.plaid_transaction_id == txn.transaction_id
                ).first()
                if existing:
                    db.delete(existing)
                    removed_count += 1

            cursor = response.next_cursor
            has_more = response.has_more

        # Update account state
        account.plaid_cursor = cursor
        account.last_synced_at = datetime.utcnow()
        account.last_sync_error = None

        # Log the sync
        duration = (datetime.utcnow() - start_time).total_seconds()
        sync_log = SyncLog(
            account_id=account.id,
            trigger=trigger,
            status=&quot;success&quot;,
            added=added_count,
            modified=modified_count,
            removed=removed_count,
            duration_seconds=duration,
        )
        db.add(sync_log)
        db.commit()

        return {
            &quot;added&quot;: added_count,
            &quot;modified&quot;: modified_count,
            &quot;removed&quot;: removed_count,
        }

    except Exception as e:
        # Log the failure
        sync_log = SyncLog(
            account_id=account.id,
            trigger=trigger,
            status=&quot;error&quot;,
            error_message=str(e),
            duration_seconds=(datetime.utcnow() - start_time).total_seconds(),
        )
        db.add(sync_log)
        db.commit()
        raise
</code></pre>
<p>Key details:</p>
<ul>
<li><strong>Cursor-based pagination</strong>: Plaid maintains a cursor that tracks your last sync position. Each call returns only what's changed since that cursor, making syncs fast and bandwidth-efficient.</li>
<li><strong>Pending transactions skipped</strong>: Plaid marks transactions as "pending" before they clear. We skip these to avoid duplicates (they reappear as non-pending later).</li>
<li><strong>Deduplication</strong>: The <code>plaid_transaction_id</code> unique constraint prevents duplicate imports.</li>
<li><strong>Auto-categorization</strong>: Each new transaction is immediately run through the 3-tier categorization engine (covered in Part 4).</li>
<li><strong>Mutation retry</strong>: Plaid sometimes returns <code>TRANSACTIONS_SYNC_MUTATION_DURING_PAGINATION</code> errors. The service retries up to 3 times with the cursor reset.</li>
<li><strong>SyncLog</strong>: Every sync attempt (success or failure) is recorded in the <code>sync_log</code> table for the audit trail.</li>
</ul>
<hr>
<h2 id="33-accounts-router-backendroutersaccountspy">3.3 Accounts Router (<code>backend/routers/accounts.py</code>)</h2>
<p>The accounts API handles listing accounts, the Plaid Link flow, manual syncing, and sync history.</p>
<h3 id="listing-accounts">Listing Accounts</h3>
<pre><code class="language-python">@router.get(&quot;&quot;)
def list_accounts(db: Session = Depends(get_db)):
    accounts = db.query(Account).all()
    result = []
    for acct in accounts:
        txn_count = db.query(Transaction).filter(
            Transaction.account_id == acct.id
        ).count()
        # Get date range coverage
        earliest = db.query(func.min(Transaction.date)).filter(
            Transaction.account_id == acct.id
        ).scalar()
        latest = db.query(func.max(Transaction.date)).filter(
            Transaction.account_id == acct.id
        ).scalar()
        result.append({
            &quot;id&quot;: acct.id,
            &quot;name&quot;: acct.name,
            &quot;institution&quot;: acct.institution,
            &quot;account_type&quot;: acct.account_type,
            &quot;plaid_connection_status&quot;: acct.plaid_connection_status,
            &quot;last_synced_at&quot;: acct.last_synced_at,
            &quot;balance_current&quot;: acct.balance_current,
            &quot;transaction_count&quot;: txn_count,
            &quot;earliest_date&quot;: str(earliest) if earliest else None,
            &quot;latest_date&quot;: str(latest) if latest else None,
        })
    return result
</code></pre>
<h3 id="plaid-link-flow">Plaid Link Flow</h3>
<p>Two endpoints handle the Plaid Link widget flow:</p>
<pre><code class="language-python">@router.post(&quot;/link/create&quot;)
def create_link_token(db: Session = Depends(get_db)):
    &quot;&quot;&quot;Create a Plaid Link token for the frontend widget.&quot;&quot;&quot;
    plaid = PlaidService()
    link_token = plaid.create_link_token()
    return {&quot;link_token&quot;: link_token}


@router.post(&quot;/link/exchange&quot;)
def exchange_public_token(body: dict, db: Session = Depends(get_db)):
    &quot;&quot;&quot;Exchange the public token from Plaid Link for an access token.&quot;&quot;&quot;
    plaid = PlaidService()
    result = plaid.exchange_public_token(
        account_id=body[&quot;account_id&quot;],
        public_token=body[&quot;public_token&quot;],
        db=db,
    )
    return result
</code></pre>
<h3 id="sync-endpoints">Sync Endpoints</h3>
<pre><code class="language-python">@router.post(&quot;/{account_id}/sync&quot;)
def sync_account(account_id: int, db: Session = Depends(get_db)):
    &quot;&quot;&quot;Manually trigger a transaction sync for one account.&quot;&quot;&quot;
    account = db.query(Account).get(account_id)
    if not account or account.plaid_connection_status != &quot;connected&quot;:
        raise HTTPException(status_code=400, detail=&quot;Account not connected&quot;)

    plaid = PlaidService()
    result = plaid.sync_transactions(account, db, trigger=&quot;manual&quot;)
    return result


@router.post(&quot;/sync-all&quot;)
def sync_all_accounts(db: Session = Depends(get_db)):
    &quot;&quot;&quot;Sync all connected accounts at once.&quot;&quot;&quot;
    accounts = db.query(Account).filter(
        Account.plaid_connection_status == &quot;connected&quot;
    ).all()

    plaid = PlaidService()
    results = {}
    for account in accounts:
        try:
            results[account.name] = plaid.sync_transactions(
                account, db, trigger=&quot;manual&quot;
            )
        except Exception as e:
            results[account.name] = {&quot;error&quot;: str(e)}
    return results
</code></pre>
<h3 id="sync-history">Sync History</h3>
<blockquote>
<p><strong>Important</strong>: This endpoint uses a literal path <code>/sync-history</code>. It MUST be defined before any parameterized path like <code>/{account_id}</code>, otherwise FastAPI will try to parse <code>"sync-history"</code> as an integer account ID.</p>
</blockquote>
<pre><code class="language-python"># NOTE: Literal paths MUST be defined before parameterised paths
# so FastAPI matches them first.

@router.get(&quot;/sync-history&quot;)
def get_sync_history(
    account_id: int = None,
    limit: int = 50,
    db: Session = Depends(get_db),
):
    &quot;&quot;&quot;Return recent sync log entries.&quot;&quot;&quot;
    query = db.query(SyncLog).order_by(SyncLog.started_at.desc())
    if account_id:
        query = query.filter(SyncLog.account_id == account_id)
    logs = query.limit(limit).all()
    return [
        {
            &quot;id&quot;: log.id,
            &quot;account_id&quot;: log.account_id,
            &quot;account_name&quot;: log.account.name if log.account else &quot;Unknown&quot;,
            &quot;trigger&quot;: log.trigger,
            &quot;status&quot;: log.status,
            &quot;added&quot;: log.added,
            &quot;modified&quot;: log.modified,
            &quot;removed&quot;: log.removed,
            &quot;error_message&quot;: log.error_message,
            &quot;duration_seconds&quot;: log.duration_seconds,
            &quot;started_at&quot;: log.started_at.isoformat() if log.started_at else None,
        }
        for log in logs
    ]
</code></pre>
<h3 id="disconnect">Disconnect</h3>
<p>Disconnects an account from Plaid while preserving all transaction data:</p>
<pre><code class="language-python">@router.post(&quot;/{account_id}/disconnect&quot;)
def disconnect_account(account_id: int, db: Session = Depends(get_db)):
    account = db.query(Account).get(account_id)
    if not account:
        raise HTTPException(status_code=404)

    account.plaid_connection_status = &quot;disconnected&quot;
    account.plaid_access_token = None
    account.plaid_cursor = None
    account.plaid_item_id = None
    account.plaid_account_id = None
    db.commit()
    return {&quot;status&quot;: &quot;disconnected&quot;}
</code></pre>
<hr>
<h2 id="34-balance-fetching">3.4 Balance Fetching</h2>
<p>The service also fetches current account balances from Plaid:</p>
<pre><code class="language-python">def fetch_balances(self, account, db):
    &quot;&quot;&quot;Fetch current balances from Plaid.&quot;&quot;&quot;
    access_token = self.decrypt_token(account.plaid_access_token)
    response = self.client.accounts_get(
        AccountsGetRequest(access_token=access_token)
    )

    for plaid_acct in response.accounts:
        if plaid_acct.account_id == account.plaid_account_id:
            account.balance_current = plaid_acct.balances.current
            account.balance_available = plaid_acct.balances.available
            account.balance_limit = plaid_acct.balances.limit
            account.balance_updated_at = datetime.utcnow()
            break

    db.commit()
</code></pre>
<hr>
<h2 id="35-oauth-callback-handling">3.5 OAuth Callback Handling</h2>
<p>Some banks (like Chase, Wells Fargo) use OAuth instead of Plaid's in-widget login. For these, Plaid redirects the user to the bank's website, then back to your app. The frontend handles this redirect:</p>
<pre><code class="language-jsx">// frontend/src/App.jsx — OAuthCallback component

function OAuthCallback() {
  const navigate = useNavigate()
  const linkToken = sessionStorage.getItem('plaid_link_token')
  const accountId = sessionStorage.getItem('plaid_account_id')

  const onSuccess = useCallback(async (publicToken) =&gt; {
    const res = await fetch('/api/accounts/link/exchange', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        account_id: parseInt(accountId),
        public_token: publicToken,
      }),
    })
    if (res.ok) {
      sessionStorage.removeItem('plaid_link_token')
      sessionStorage.removeItem('plaid_account_id')
      navigate('/accounts')
    }
  }, [accountId, navigate])

  const { open, ready } = usePlaidLink({
    token: linkToken,
    onSuccess,
    onExit: () =&gt; navigate('/accounts'),
    receivedRedirectUri: window.location.href,
  })

  useEffect(() =&gt; {
    if (ready) open()
  }, [ready, open])

  return &lt;div className=&quot;empty-state&quot;&gt;&lt;p&gt;Completing bank connection...&lt;/p&gt;&lt;/div&gt;
}
</code></pre>
<p>Before opening the Plaid Link widget for an OAuth bank, the frontend stores the link token and account ID in <code>sessionStorage</code> so they survive the redirect. When Plaid redirects back to <code>/oauth-callback</code>, this component picks up where it left off.</p>
<hr>
<h2 id="whats-next">What's Next</h2>
<p>With bank accounts connected and transactions flowing in, Part 4 covers how those transactions get categorized: the 3-tier categorization engine, the review workflow, CSV import, and seed data.</p>
<p>→ <a href="04-categorization-engine.md">Part 4: Transaction Processing &amp; Categorization</a></p>
      </div>
      <div class="docs-nav-footer">
        <a href="02-database-and-models.html" class="docs-nav-link prev">
  <span class="label">&larr; Previous</span>
  <span class="title">Database Models & Backend Core</span>
</a>
        <a href="04-categorization-engine.html" class="docs-nav-link next">
  <span class="label">Next &rarr;</span>
  <span class="title">Categorization Engine</span>
</a>
      </div>
    </main>
  </div>
</body>
</html>
